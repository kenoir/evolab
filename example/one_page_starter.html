<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EvoLab: Final Working Fix</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; color: #e0e0e0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; touch-action: none; }
        canvas { display: block; }
        .stat-card { background: rgba(25, 25, 25, 0.95); backdrop-filter: blur(6px); border: 1px solid #333; transition: all 0.3s ease; }
        .no-select { user-select: none; -webkit-user-select: none; }
        .graph-label { font-size: 10px; color: #888; text-transform: uppercase; letter-spacing: 0.5px; margin-top: 2px; display: flex; justify-content: space-between;}
        
        .scrollable-y { overflow-y: auto; max-height: 80vh; }
        .scrollable-y::-webkit-scrollbar { width: 4px; }
        .scrollable-y::-webkit-scrollbar-thumb { background: #444; border-radius: 2px; }
        
        .collapsible-content { overflow: hidden; transition: max-height 0.3s ease-out; max-height: 600px; }
        .collapsed .collapsible-content { max-height: 0px; }
        .rotate-icon { transition: transform 0.3s; }
        .collapsed .rotate-icon { transform: rotate(-90deg); }
    </style>
</head>
<body class="no-select">

<!-- Error Trap -->
<div id="error-log" class="absolute top-0 left-0 w-full h-full bg-red-900 text-white p-4 hidden z-50 overflow-auto font-mono text-sm">
    <h2 class="text-xl font-bold mb-2">Simulation Status</h2>
    <pre id="error-text"></pre>
    <button onclick="location.reload()" class="mt-4 bg-white text-red-900 px-4 py-2 rounded">Reload</button>
</div>

<!-- UI Layer -->
<div class="absolute top-0 left-0 w-full h-full pointer-events-none flex flex-col justify-between p-4 z-20">
    
    <!-- Top Left: Stats -->
    <div class="flex flex-wrap justify-between items-start gap-4 pointer-events-auto">
        <div id="stats-card" class="stat-card p-3 rounded-lg shadow-xl w-64">
            <div class="flex justify-between items-center mb-2 cursor-pointer" id="stats-header">
                <div>
                    <h1 class="text-lg font-bold text-green-400 leading-none">EvoLab <span class="text-[10px] text-gray-500 font-normal">v31.0 Fixed</span></h1>
                    <div class="flex items-baseline gap-2 mt-1">
                        <span class="text-xs text-gray-400">Pop:</span>
                        <span id="pop-count" class="font-mono font-bold text-white text-sm">0</span>
                        <span class="text-[10px] text-gray-500 ml-2">Food: <span id="food-count">0</span></span>
                    </div>
                </div>
                <button class="text-gray-400 hover:text-white p-1 rotate-icon">▼</button>
            </div>
            
            <div class="collapsible-content">
                <div class="pt-2 border-t border-gray-700 space-y-2">
                    <div><div class="graph-label"><span class="text-blue-400">Speed</span></div><canvas id="hist-speed" width="220" height="25" class="bg-gray-900 rounded border border-gray-700"></canvas></div>
                    <div><div class="graph-label"><span class="text-red-400">Size</span></div><canvas id="hist-size" width="220" height="25" class="bg-gray-900 rounded border border-gray-700"></canvas></div>
                    <div><div class="graph-label"><span class="text-green-400">Sense</span></div><canvas id="hist-sense" width="220" height="25" class="bg-gray-900 rounded border border-gray-700"></canvas></div>
                    <div><div class="graph-label"><span class="text-purple-400">Storage</span></div><canvas id="hist-storage" width="220" height="25" class="bg-gray-900 rounded border border-gray-700"></canvas></div>
                    <div><div class="graph-label"><span class="text-cyan-400">Metabolism</span></div><canvas id="hist-meta" width="220" height="25" class="bg-gray-900 rounded border border-gray-700"></canvas></div>
                    <div><div class="graph-label"><span class="text-yellow-400">Defense</span></div><canvas id="hist-defense" width="220" height="25" class="bg-gray-900 rounded border border-gray-700"></canvas></div>
                </div>
            </div>
        </div>

        <!-- FPS & Status -->
        <div class="stat-card p-3 rounded-lg shadow-xl flex gap-6 items-center h-fit">
             <div class="text-center">
                <div class="text-[10px] text-gray-500 uppercase">Active Zones</div>
                <div id="zone-count" class="text-lg font-bold text-purple-400">0</div>
            </div>
            <div class="h-8 w-px bg-gray-700"></div>
            <div class="text-center">
                <div class="text-[10px] text-gray-500 uppercase">FPS</div>
                <div id="fps-counter" class="text-lg font-bold text-gray-300">60</div>
            </div>
        </div>

        <!-- Desktop Controls -->
        <div class="stat-card p-3 rounded-lg shadow-xl text-xs hidden md:block scrollable-y w-48 max-h-[calc(100vh-200px)]">
            <div class="font-bold mb-2 text-gray-300 border-b border-gray-600 pb-1">Configuration</div>
            
            <div class="mb-3">
                <label class="block text-[10px] uppercase text-gray-500 mb-1">World Size</label>
                <select id="world-size-select" class="bg-gray-800 text-white border border-gray-600 rounded px-2 py-1 w-full text-xs">
                    <option value="3000" selected>Medium (3k)</option>
                    <option value="6000">Large (6k)</option>
                    <option value="12000">Massive (12k)</option>
                    <option value="30000">Gigantic (30k)</option>
                    <option value="60000">Planetary (60k)</option>
                </select>
            </div>

            <div class="space-y-2 mb-3">
                <div class="font-bold text-gray-400 text-[10px] uppercase mt-2">Ecosystem</div>
                <div class="flex items-center"><input type="checkbox" id="predation-toggle" class="w-4 h-4 accent-red-500 mr-2 cursor-pointer" checked><label for="predation-toggle" class="text-red-400 font-bold cursor-pointer ml-1">Predation</label></div>
                
                <div class="font-bold text-gray-400 text-[10px] uppercase mt-2">Hazards</div>
                <div class="flex items-center"><input type="checkbox" id="zones-toggle" class="w-4 h-4 accent-purple-500 mr-2 cursor-pointer" checked><label for="zones-toggle" class="text-purple-400 font-bold cursor-pointer ml-1">Rad Zones</label></div>
                <div class="mt-1"><label class="block text-[9px] text-gray-500 uppercase">Density</label><input type="range" id="zone-density" min="1" max="20" value="5" class="w-full accent-purple-500 h-1"></div>
                <div class="mt-1"><label class="block text-[9px] text-gray-500 uppercase">Size</label><input type="range" id="zone-size" min="100" max="1000" value="350" class="w-full accent-purple-500 h-1"></div>
                <div class="mt-1"><label class="block text-[9px] text-gray-500 uppercase">Drift</label><input type="range" id="zone-drift" min="0" max="50" value="3" class="w-full accent-purple-500 h-1"></div>
                
                <div class="font-bold text-gray-400 text-[10px] uppercase mt-2">System</div>
                <div class="flex items-center"><input type="checkbox" id="debug-toggle" class="w-4 h-4 accent-blue-500 mr-2 cursor-pointer"><label for="debug-toggle" class="text-blue-400 font-bold cursor-pointer ml-1">Debug View</label></div>
            </div>

            <div>
                <label class="block text-gray-500 text-[10px] uppercase">Time Scale</label>
                <input type="range" id="sim-speed" min="1" max="20" value="1" class="w-full accent-green-500">
            </div>
            <div class="mt-2">
                <label class="block text-gray-500 text-[10px] uppercase">Mutation Chance</label>
                <input type="range" id="mut-rate" min="0" max="100" value="90" class="w-full accent-pink-500">
            </div>
            <div class="mt-2">
                <label class="block text-gray-500 text-[10px] uppercase">Energy Burn Rate</label>
                <div class="flex justify-between text-[9px] text-gray-600"><span>Slow</span><span>Fast</span></div>
                <input type="range" id="metabolism" min="1" max="200" value="20" class="w-full accent-teal-500">
            </div>
            <div class="mt-3 text-right">
                <button id="reset-btn" class="bg-gray-700 hover:bg-red-800 text-white px-3 py-1 rounded transition w-full">Reset World</button>
            </div>
        </div>
        
        <button id="mobile-menu-btn" class="md:hidden pointer-events-auto bg-gray-800 p-2 rounded text-white opacity-80">⚙️</button>
    </div>

    <!-- Mobile Menu -->
    <div id="mobile-menu" class="hidden pointer-events-auto stat-card p-4 rounded-lg absolute top-16 right-4 flex-col gap-3 w-48">
        <div><label class="text-[10px] uppercase text-gray-500">World</label><select id="mob-world-size" class="bg-gray-800 text-white border border-gray-600 rounded px-2 py-1 w-full text-xs mt-1"><option value="3000">Medium</option><option value="12000">Massive</option><option value="60000">Planetary</option></select></div>
        <div class="flex items-center"><input type="checkbox" id="mob-predation" class="w-4 h-4 accent-red-500 mr-2" checked><label class="text-red-400 text-xs font-bold">Predation</label></div>
        <div class="flex items-center"><input type="checkbox" id="mob-zones" class="w-4 h-4 accent-purple-500 mr-2" checked><label class="text-purple-400 text-xs font-bold">Rad Zones</label></div>
        <div><label class="text-gray-500 text-[10px] uppercase">Zone Density</label><input type="range" id="mob-zone-density" min="1" max="20" value="5" class="w-full accent-purple-500"></div>
        <div class="flex items-center"><input type="checkbox" id="mob-debug" class="w-4 h-4 accent-blue-500 mr-2"><label class="text-blue-400 text-xs font-bold">Debug View</label></div>
        <div><label class="text-gray-500 text-[10px] uppercase">Speed</label><input type="range" id="mob-speed" min="1" max="20" value="1" class="w-full accent-green-500"></div>
        <div><label class="text-gray-500 text-[10px] uppercase">Mutation</label><input type="range" id="mob-mut" min="0" max="100" value="90" class="w-full accent-pink-500"></div>
        <div><label class="text-gray-500 text-[10px] uppercase">Burn Rate</label><input type="range" id="mob-metabolism" min="1" max="200" value="20" class="w-full accent-teal-500"></div>
        <button id="mob-reset" class="bg-gray-700 text-xs py-1 w-full rounded">Reset</button>
    </div>

    <!-- Minimap -->
    <div class="absolute bottom-4 right-4 pointer-events-auto flex flex-col items-end gap-2">
        <div class="text-[10px] text-gray-500 uppercase tracking-widest">Minimap</div>
        <canvas id="minimap" width="120" height="120" class="minimap-container rounded shadow-lg"></canvas>
    </div>
</div>

<canvas id="simCanvas" class="z-10 cursor-move"></canvas>

<script>
// 1. Error Trap
window.onerror = function(msg, url, line) {
    const log = document.getElementById('error-log');
    const text = document.getElementById('error-text');
    if(log && text) {
        log.classList.remove('hidden');
        text.innerText += `Error: ${msg}\nLine: ${line}\n\n`;
    }
    return false; 
};

// 2. Global Variables
let canvas, ctx, miniCanvas, miniCtx;
let histSpeedCtx, histSizeCtx, histSenseCtx, histStorageCtx, histMetaCtx, histDefenseCtx;

const MAX_POP = 100000; 
const MAX_FOOD = 50000;

let worldSize = 3000;
let cellSize = 320;
let simSpeed = 1;
let debugMode = false;
let lastTime = 0;
let predationActive = true;
let frameCount = 0;

let camera = { x: 0, y: 0, zoom: 0.5 };
let isDragging = false;
let dragDistance = 0;
let lastMouse = { x: 0, y: 0 };
let initialPinchDist = 0;
let initialZoom = 1;
let keys = {};

const CONFIG = {
    initialPop: 50,
    initialFood: 150,
    mutationRate: 0.5, 
    mutationChance: 0.9, 
    baseMetabolism: 0.002,
    startEnergy: 150,
    predatorSizeAdvantage: 1.2,
    foodValue: 25,
    maxToxicity: 0.9,
    zoneCount: 5,
    zoneDensity: 5,
    zoneDrift: 0.3,
    zoneSize: 350
};

const ENV = { zones: [], activeZones: true };

// 3. Memory (SoA)
const oX = new Float32Array(MAX_POP);
const oY = new Float32Array(MAX_POP);
const oVX = new Float32Array(MAX_POP);
const oVY = new Float32Array(MAX_POP);
const oEnergy = new Float32Array(MAX_POP);

const gSpeed = new Float32Array(MAX_POP);
const gSize = new Float32Array(MAX_POP);
const gSense = new Float32Array(MAX_POP);
const gRepro = new Float32Array(MAX_POP); 
const gWander = new Float32Array(MAX_POP);
const gDefense = new Float32Array(MAX_POP);
const gMeta = new Float32Array(MAX_POP);
const gHue = new Float32Array(MAX_POP);

const oActive = new Uint8Array(MAX_POP);
const oFree = new Int32Array(MAX_POP); 
let oFreePtr = MAX_POP - 1; 
let activeCount = 0;

const fX = new Float32Array(MAX_FOOD);
const fY = new Float32Array(MAX_FOOD);
const fActive = new Uint8Array(MAX_FOOD);
const fFree = new Int32Array(MAX_FOOD);
let fFreePtr = MAX_FOOD - 1;
let foodCount = 0;

const MAX_GRID_DIM = 500; 
const MAX_CELLS = MAX_GRID_DIM * MAX_GRID_DIM;
const gridHead = new Int32Array(MAX_CELLS);
const gridNext = new Int32Array(MAX_POP);
const foodGridHead = new Int32Array(MAX_CELLS);
const foodGridNext = new Int32Array(MAX_FOOD);
let gridCols = 0, gridRows = 0;

const HIST_BINS = 20;
const hSpeeds = new Int32Array(HIST_BINS);
const hSizes = new Int32Array(HIST_BINS);
const hSenses = new Int32Array(HIST_BINS);
const hStorage = new Int32Array(HIST_BINS);
const hMetas = new Int32Array(HIST_BINS);
const hDefense = new Int32Array(HIST_BINS);

for(let i=0; i<MAX_POP; i++) oFree[i] = MAX_POP - 1 - i;
for(let i=0; i<MAX_FOOD; i++) fFree[i] = MAX_FOOD - 1 - i;

// 4. Logic Functions
function safeGet(id) {
    const el = document.getElementById(id);
    if (!el) console.warn(`UI element ${id} missing`);
    return el;
}

class Vector {
    constructor(x, y) { this.x = x; this.y = y; }
}

function getWrappedVector(fromX, fromY, toX, toY) {
    let dx = toX - fromX; let dy = toY - fromY;
    if (dx > worldSize / 2) dx -= worldSize; else if (dx < -worldSize / 2) dx += worldSize;
    if (dy > worldSize / 2) dy -= worldSize; else if (dy < -worldSize / 2) dy += worldSize;
    return {x: dx, y: dy};
}
function getWrappedDistSq(x1, y1, x2, y2) {
    let dx = Math.abs(x1 - x2); let dy = Math.abs(y1 - y2);
    if (dx > worldSize / 2) dx = worldSize - dx; if (dy > worldSize / 2) dy = worldSize - dy;
    return dx * dx + dy * dy;
}
function getWrappedDist(x1, y1, x2, y2) { return Math.sqrt(getWrappedDistSq(x1, y1, x2, y2)); }

function getBiasedSpawnPos() {
    if (ENV.activeZones && ENV.zones.length > 0 && Math.random() < 0.8) { 
        const zone = ENV.zones[Math.floor(Math.random() * ENV.zones.length)];
        const r = zone.radius * Math.sqrt(Math.random()); 
        const theta = Math.random() * 2 * Math.PI;
        let x = zone.pos.x + r * Math.cos(theta);
        let y = zone.pos.y + r * Math.sin(theta);
        if (x < 0) x += worldSize; if (x >= worldSize) x -= worldSize;
        if (y < 0) y += worldSize; if (y >= worldSize) y -= worldSize;
        return {x, y};
    }
    return {x: Math.random()*worldSize, y: Math.random()*worldSize};
}

function spawnOrganism(x, y, parentIdx = -1) {
    if (oFreePtr < 0) return -1;
    const idx = oFree[oFreePtr--];
    oActive[idx] = 1;
    activeCount++;

    oX[idx] = x; oY[idx] = y;
    oVX[idx] = (Math.random() - 0.5); oVY[idx] = (Math.random() - 0.5);

    if (parentIdx === -1) {
        gSpeed[idx] = Math.random() * 2 + 1.5;
        gSize[idx] = Math.random() * 8 + 5;
        gSense[idx] = Math.random() * 80 + 40;
        gRepro[idx] = Math.random() * 1900 + 100;
        gWander[idx] = Math.random() * 0.5 + 0.1;
        gDefense[idx] = Math.random() * 0.1;
        gMeta[idx] = 1.0;
        gHue[idx] = Math.random() * 360;
    } else {
        const chance = CONFIG.mutationChance;
        const rate = CONFIG.mutationRate;
        gSpeed[idx] = gSpeed[parentIdx]; gSize[idx] = gSize[parentIdx]; gSense[idx] = gSense[parentIdx];
        gRepro[idx] = gRepro[parentIdx]; gWander[idx] = gWander[parentIdx]; gDefense[idx] = gDefense[parentIdx];
        gMeta[idx] = gMeta[parentIdx]; gHue[idx] = gHue[parentIdx];

        if (Math.random() < chance) gSpeed[idx] += (Math.random() - 0.5) * rate * 2;
        if (Math.random() < chance) gSize[idx] += (Math.random() - 0.5) * rate * 6;
        if (Math.random() < chance) gSense[idx] += (Math.random() - 0.5) * rate * 30;
        if (Math.random() < chance) gRepro[idx] += (Math.random() - 0.5) * 400 * rate;
        if (Math.random() < chance) gWander[idx] += (Math.random() - 0.5) * 0.2;
        if (Math.random() < chance) gDefense[idx] += (Math.random() - 0.5) * 0.3;
        if (Math.random() < chance) gMeta[idx] += (Math.random() - 0.5) * rate * 0.5;
        if (Math.random() < chance) gHue[idx] += (Math.random() - 0.5) * 30;

        gSpeed[idx] = Math.max(0.5, Math.min(8, gSpeed[idx]));
        gSize[idx] = Math.max(4, Math.min(30, gSize[idx]));
        gSense[idx] = Math.max(20, Math.min(300, gSense[idx]));
        gRepro[idx] = Math.max(100, Math.min(2500, gRepro[idx]));
        gWander[idx] = Math.max(0.05, Math.min(2, gWander[idx]));
        gDefense[idx] = Math.max(0, Math.min(1, gDefense[idx]));
        gMeta[idx] = Math.max(0.5, Math.min(3.0, gMeta[idx]));
        gHue[idx] = (gHue[idx] + 360) % 360;
    }
    oEnergy[idx] = gRepro[idx] * 0.5;
    return idx;
}

function killOrganism(idx) {
    oActive[idx] = 0;
    oFree[++oFreePtr] = idx;
    activeCount--;
}

function spawnFood(x, y) {
    if (fFreePtr < 0) return -1;
    const idx = fFree[fFreePtr--];
    fActive[idx] = 1;
    fX[idx] = x; fY[idx] = y;
    foodCount++;
    return idx;
}

function killFood(idx) {
    fActive[idx] = 0;
    fFree[++fFreePtr] = idx;
    foodCount--;
}

function updateGrid() {
    gridCols = Math.ceil(worldSize / cellSize);
    gridRows = Math.ceil(worldSize / cellSize);
    gridHead.fill(-1, 0, gridCols * gridRows);
    foodGridHead.fill(-1, 0, gridCols * gridRows);

    for(let i=0; i<MAX_POP; i++) {
        if(oActive[i]) {
            let cx = Math.floor(oX[i] / cellSize);
            let cy = Math.floor(oY[i] / cellSize);
            if(cx < 0) cx += gridCols; if(cx >= gridCols) cx %= gridCols;
            if(cy < 0) cy += gridRows; if(cy >= gridRows) cy %= gridRows;
            const cellIdx = cy * gridCols + cx;
            gridNext[i] = gridHead[cellIdx];
            gridHead[cellIdx] = i;
        }
    }

    for(let i=0; i<MAX_FOOD; i++) {
        if(fActive[i]) {
            let cx = Math.floor(fX[i] / cellSize);
            let cy = Math.floor(fY[i] / cellSize);
            if(cx < 0) cx += gridCols; if(cx >= gridCols) cx %= gridCols;
            if(cy < 0) cy += gridRows; if(cy >= gridRows) cy %= gridRows;
            const cellIdx = cy * gridCols + cx;
            foodGridNext[i] = foodGridHead[cellIdx];
            foodGridHead[cellIdx] = i;
        }
    }
}

function physicsStep() {
    for(let i=0; i<MAX_POP; i++) {
        if(!oActive[i]) continue;

        const speedMag = Math.sqrt(oVX[i]*oVX[i] + oVY[i]*oVY[i]);
        const metabolicSpeedLimit = gMeta[i] * 4.0;
        if (speedMag > metabolicSpeedLimit) {
            const scale = metabolicSpeedLimit / speedMag;
            oVX[i] *= scale; oVY[i] *= scale;
        }

        const baseCost = CONFIG.baseMetabolism * gMeta[i];
        const speedCost = (speedMag ** 3) * 0.02;
        const sizeCost = (gSize[i] ** 3) * 0.0001;
        const senseCost = gSense[i] * 0.0001;
        const defenseCost = gDefense[i] * 0.08;
        oEnergy[i] -= (baseCost + speedCost + sizeCost + senseCost + defenseCost);

        if (ENV.activeZones) {
            for(let z of ENV.zones) {
                const dist = getWrappedDist(oX[i], oY[i], z.pos.x, z.pos.y);
                if (dist < z.radius) {
                    const intensity = 1.0 - (dist / z.radius);
                    const damage = Math.max(0, (intensity * CONFIG.maxToxicity) - gDefense[i]);
                    oEnergy[i] -= damage;
                }
            }
        }

        if (oEnergy[i] <= 0) { killOrganism(i); continue; }

        let cx = Math.floor(oX[i] / cellSize);
        let cy = Math.floor(oY[i] / cellSize);
        let bestFood = -1; let bestFoodDist = Infinity;
        let bestPred = -1; let bestPredDist = Infinity;
        const senseSq = gSense[i] * gSense[i];

        for(let dy=-1; dy<=1; dy++) {
            for(let dx=-1; dx<=1; dx++) {
                let nx = (cx + dx + gridCols) % gridCols;
                let ny = (cy + dy + gridRows) % gridRows;
                let cellIdx = ny * gridCols + nx;

                let fIdx = foodGridHead[cellIdx];
                while(fIdx !== -1) {
                    if (fActive[fIdx]) {
                        const dSq = getWrappedDistSq(oX[i], oY[i], fX[fIdx], fY[fIdx]);
                        if (dSq < senseSq && dSq < bestFoodDist) {
                            bestFoodDist = dSq; bestFood = fIdx;
                        }
                    }
                    fIdx = foodGridNext[fIdx];
                }
                if (predationActive) {
                    let oIdx = gridHead[cellIdx];
                    while(oIdx !== -1) {
                        if (oIdx !== i && oActive[oIdx]) {
                            const dSq = getWrappedDistSq(oX[i], oY[i], oX[oIdx], oY[oIdx]);
                            if (dSq < senseSq) {
                                if (gSize[oIdx] > gSize[i] * CONFIG.predatorSizeAdvantage) {
                                    if (dSq < bestPredDist) { bestPredDist = dSq; bestPred = oIdx; }
                                } else if (gSize[i] > gSize[oIdx] * CONFIG.predatorSizeAdvantage) {
                                    if (dSq < bestFoodDist) { bestFoodDist = dSq; bestFood = -2; } 
                                }
                            }
                        }
                        oIdx = gridNext[oIdx];
                    }
                }
            }
        }

        let accX = 0, accY = 0;
        if (bestPred !== -1) {
            let v = getWrappedVector(oX[bestPred], oY[bestPred], oX[i], oY[i]); 
            const dist = Math.sqrt(v.x*v.x + v.y*v.y);
            if (dist > 0) { accX = (v.x/dist) * 0.6; accY = (v.y/dist) * 0.6; }
            oEnergy[i] -= 0.1;
        } else if (bestFood !== -1) {
            let tx = (bestFood === -2) ? oX[i] : fX[bestFood]; 
            let ty = (bestFood === -2) ? oY[i] : fY[bestFood];
            if (bestFood >= 0) {
                let v = getWrappedVector(oX[i], oY[i], tx, ty);
                const dist = Math.sqrt(v.x*v.x + v.y*v.y);
                if (dist > 0) { accX = (v.x/dist) * 0.25; accY = (v.y/dist) * 0.25; }
            } else {
                const ag = gWander[i];
                accX = (Math.random()-0.5) * ag; accY = (Math.random()-0.5) * ag;
            }
        } else {
            const ag = gWander[i];
            accX = (Math.random()-0.5) * ag; accY = (Math.random()-0.5) * ag;
        }

        oVX[i] += accX; oVY[i] += accY;
        const velMag2 = Math.sqrt(oVX[i]*oVX[i] + oVY[i]*oVY[i]);
        if (velMag2 > gSpeed[i]) {
            const scale = gSpeed[i] / velMag2;
            oVX[i] *= scale; oVY[i] *= scale;
        }
        oX[i] += oVX[i]; oY[i] += oVY[i];
        
        if (oX[i] < 0) oX[i] += worldSize; if (oX[i] >= worldSize) oX[i] -= worldSize;
        if (oY[i] < 0) oY[i] += worldSize; if (oY[i] >= worldSize) oY[i] -= worldSize;

        cx = Math.floor(oX[i] / cellSize);
        cy = Math.floor(oY[i] / cellSize);
        if(cx < 0) cx += gridCols; if(cx >= gridCols) cx %= gridCols;
        if(cy < 0) cy += gridRows; if(cy >= gridRows) cy %= gridRows;
        const cellIdx = cy * gridCols + cx;
        const eatRadSq = (gSize[i] + 3)**2;

        let fIdx = foodGridHead[cellIdx];
        while(fIdx !== -1) {
            if (fActive[fIdx]) {
                const dSq = getWrappedDistSq(oX[i], oY[i], fX[fIdx], fY[fIdx]);
                if (dSq < eatRadSq) {
                    oEnergy[i] = Math.min(gRepro[i] * 1.2, oEnergy[i] + CONFIG.foodValue);
                    killFood(fIdx);
                }
            }
            fIdx = foodGridNext[fIdx];
        }

        if (predationActive) {
            let other = gridHead[cellIdx];
            while(other !== -1) {
                if (other !== i && oActive[other]) {
                    if (gSize[i] > gSize[other] * CONFIG.predatorSizeAdvantage) {
                        const dSq = getWrappedDistSq(oX[i], oY[i], oX[other], oY[other]);
                        if (dSq < gSize[i]*gSize[i]) {
                            const dmg = gDefense[other] * 30;
                            oEnergy[i] -= dmg;
                            oEnergy[i] = Math.min(gRepro[i] * 1.5, oEnergy[i] + oEnergy[other] + gSize[other]*5);
                            killOrganism(other);
                        }
                    }
                }
                other = gridNext[other];
            }
        }

        if (oEnergy[i] > gRepro[i]) {
            let costPerChild = 300;
            if (oEnergy[i] > 600) costPerChild = 280;
            if (oEnergy[i] > 1200) costPerChild = 260;

            let numOffspring = Math.floor(oEnergy[i] / costPerChild);
            if (numOffspring < 1) numOffspring = 1;
            if (numOffspring > 8) numOffspring = 8;
            
            let share = oEnergy[i] / (numOffspring + 1);
            oEnergy[i] = share;
            for(let k=0; k<numOffspring; k++) {
                let childIdx = spawnOrganism(oX[i], oY[i], i);
                if (childIdx !== -1) oEnergy[childIdx] = share;
            }
        }
    }
}

function clampCamera() {
    if(!ctx) return;
    const viewW = ctx.canvas.width / camera.zoom; const viewH = ctx.canvas.height / camera.zoom;
    if (viewW >= worldSize) camera.x = -(viewW - worldSize) / 2; else camera.x = Math.max(0, Math.min(camera.x, worldSize - viewW));
    if (viewH >= worldSize) camera.y = -(viewH - worldSize) / 2; else camera.y = Math.max(0, Math.min(camera.y, worldSize - viewH));
}

function updateEnvironment() {
    if (ENV.activeZones) {
        const targetZoneCount = Math.ceil(CONFIG.zoneDensity * (worldSize / 3000));
        if (ENV.zones.length < targetZoneCount) {
            ENV.zones.push({
                pos: {x: Math.random() * worldSize, y: Math.random() * worldSize},
                radius: CONFIG.zoneSize,
                vel: {x: (Math.random()-0.5)*CONFIG.zoneDrift, y: (Math.random()-0.5)*CONFIG.zoneDrift}
            });
        }
        for (let z of ENV.zones) {
            z.pos.x += z.vel.x; z.pos.y += z.vel.y;
            if (z.pos.x < 0) z.pos.x += worldSize; if (z.pos.x >= worldSize) z.pos.x -= worldSize;
            if (z.pos.y < 0) z.pos.y += worldSize; if (z.pos.y >= worldSize) z.pos.y -= worldSize;
            if (Math.random() < 0.05) {
                z.vel.x = Math.max(-CONFIG.zoneDrift, Math.min(CONFIG.zoneDrift, z.vel.x + (Math.random()-0.5)*0.1));
                z.vel.y = Math.max(-CONFIG.zoneDrift, Math.min(CONFIG.zoneDrift, z.vel.y + (Math.random()-0.5)*0.1));
            }
        }
    } else {
        ENV.zones = [];
    }
}

function spawnRandomFood(amount) {
    for(let i=0; i<amount; i++) {
        let p = getBiasedSpawnPos();
        spawnFood(p.x, p.y);
    }
}

function spawnAt(clientX, clientY) {
    if(!ctx) return;
    const worldX = (clientX / camera.zoom) + camera.x; const worldY = (clientY / camera.zoom) + camera.y;
    let wx = worldX % worldSize; let wy = worldY % worldSize;
    if (wx < 0) wx += worldSize; if (wy < 0) wy += worldSize;
    for(let i=0; i<3; i++) spawnFood(wx + (Math.random()-0.5)*50, wy + (Math.random()-0.5)*50);
}

function updateHistograms() {
    if (!histSpeedCtx) return;
    histSpeedCtx.clearRect(0, 0, histSpeedCtx.canvas.width, histSpeedCtx.canvas.height);
    histSizeCtx.clearRect(0, 0, histSizeCtx.canvas.width, histSizeCtx.canvas.height);
    histSenseCtx.clearRect(0, 0, histSenseCtx.canvas.width, histSenseCtx.canvas.height);
    histStorageCtx.clearRect(0, 0, histStorageCtx.canvas.width, histStorageCtx.canvas.height);
    histMetaCtx.clearRect(0, 0, histMetaCtx.canvas.width, histMetaCtx.canvas.height);
    histDefenseCtx.clearRect(0, 0, histDefenseCtx.canvas.width, histDefenseCtx.canvas.height);

    if (activeCount === 0) return;

    hSpeeds.fill(0); hSizes.fill(0); hSenses.fill(0); hStorage.fill(0); hMetas.fill(0); hDefense.fill(0);
    let maxSpeed = 0, maxSize = 0, maxSense = 0, maxStorage = 0, maxMeta = 0, maxDefense = 0;

    for(let i=0; i<MAX_POP; i++) {
        if (oActive[i]) {
            let b = Math.floor(((gSpeed[i] - 0.5) / 7.5) * HIST_BINS); if(b<0) b=0; if(b>=HIST_BINS) b=HIST_BINS-1; hSpeeds[b]++; if(hSpeeds[b]>maxSpeed) maxSpeed=hSpeeds[b];
            b = Math.floor(((gSize[i] - 4.0) / 26.0) * HIST_BINS); if(b<0) b=0; if(b>=HIST_BINS) b=HIST_BINS-1; hSizes[b]++; if(hSizes[b]>maxSize) maxSize=hSizes[b];
            b = Math.floor(((gSense[i] - 20.0) / 280.0) * HIST_BINS); if(b<0) b=0; if(b>=HIST_BINS) b=HIST_BINS-1; hSenses[b]++; if(hSenses[b]>maxSense) maxSense=hSenses[b];
            b = Math.floor(((gRepro[i] - 150.0) / 2350.0) * HIST_BINS); if(b<0) b=0; if(b>=HIST_BINS) b=HIST_BINS-1; hStorage[b]++; if(hStorage[b]>maxStorage) maxStorage=hStorage[b];
            b = Math.floor(((gMeta[i] - 0.5) / 2.5) * HIST_BINS); if(b<0) b=0; if(b>=HIST_BINS) b=HIST_BINS-1; hMetas[b]++; if(hMetas[b]>maxMeta) maxMeta=hMetas[b];
            b = Math.floor((gDefense[i]) * HIST_BINS); if(b<0) b=0; if(b>=HIST_BINS) b=HIST_BINS-1; hDefense[b]++; if(hDefense[b]>maxDefense) maxDefense=hDefense[b];
        }
    }

    const drawBin = (ctx, counts, max, color) => {
        const w = ctx.canvas.width / HIST_BINS;
        ctx.fillStyle = color;
        for(let i=0; i<HIST_BINS; i++) {
            const h = (counts[i] / max) * ctx.canvas.height * 0.9;
            ctx.fillRect(i * w, ctx.canvas.height - h, w - 1, h);
        }
    };

    drawBin(histSpeedCtx, hSpeeds, maxSpeed, '#60a5fa');
    drawBin(histSizeCtx, hSizes, maxSize, '#f87171');
    drawBin(histSenseCtx, hSenses, maxSense, '#4ade80');
    drawBin(histStorageCtx, hStorage, maxStorage, '#a78bfa');
    drawBin(histMetaCtx, hMetas, maxMeta, '#22d3ee');
    drawBin(histDefenseCtx, hDefense, maxDefense, '#facc15');
}

function draw() {
    if(!ctx) return;
    ctx.fillStyle = '#111'; ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height); 
    ctx.save(); ctx.scale(camera.zoom, camera.zoom); ctx.translate(-camera.x, -camera.y);
    
    // Grid
    ctx.strokeStyle = '#222'; ctx.lineWidth = 2; const gridSize = 320; 
    const viewW = ctx.canvas.width / camera.zoom; const viewH = ctx.canvas.height / camera.zoom;
    const camCX = camera.x + viewW/2; const camCY = camera.y + viewH/2;
    const startX = Math.floor(camera.x / gridSize) * gridSize, startY = Math.floor(camera.y / gridSize) * gridSize;
    const endX = camera.x + viewW + gridSize, endY = camera.y + viewH + gridSize;
    ctx.beginPath();
    for (let x = startX; x < endX; x += gridSize) { ctx.moveTo(x, camera.y); ctx.lineTo(x, camera.y + viewH); }
    for (let y = startY; y < endY; y += gridSize) { ctx.moveTo(camera.x, y); ctx.lineTo(camera.x + viewW, y); }
    ctx.stroke(); ctx.strokeStyle = '#331111'; ctx.strokeRect(0, 0, worldSize, worldSize);

    if (ENV.activeZones) {
        for (let z of ENV.zones) {
             let dx = Math.abs(z.pos.x - camCX); let dy = Math.abs(z.pos.y - camCY);
             if (dx > worldSize/2) dx = worldSize - dx; if (dy > worldSize/2) dy = worldSize - dy;
             if (dx > viewW/2 + z.radius && dy > viewH/2 + z.radius) continue;
             const grad = ctx.createRadialGradient(z.pos.x, z.pos.y, 0, z.pos.x, z.pos.y, z.radius);
             grad.addColorStop(0, 'rgba(147, 51, 234, 0.4)'); grad.addColorStop(1, 'rgba(74, 222, 128, 0.0)');
             ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(z.pos.x, z.pos.y, z.radius, 0, Math.PI*2); ctx.fill();
             if (z.pos.x < z.radius) { ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(z.pos.x+worldSize, z.pos.y, z.radius, 0, Math.PI*2); ctx.fill(); }
             if (z.pos.x > worldSize-z.radius) { ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(z.pos.x-worldSize, z.pos.y, z.radius, 0, Math.PI*2); ctx.fill(); }
        }
    }

    ctx.fillStyle = '#4ade80'; ctx.beginPath();
    for (let i=0; i<MAX_FOOD; i++) {
        if (!fActive[i]) continue;
        let dx = Math.abs(fX[i] - camCX); let dy = Math.abs(fY[i] - camCY);
        if (dx > worldSize/2) dx = worldSize - dx; if (dy > worldSize/2) dy = worldSize - dy;
        if (dx > viewW/2 + 20 && dy > viewH/2 + 20) continue; 
        const drawF = (x,y) => { ctx.moveTo(x,y); ctx.arc(x, y, 3, 0, Math.PI*2); };
        drawF(fX[i], fY[i]);
        if (fX[i] < 10) drawF(fX[i]+worldSize, fY[i]); if (fX[i] > worldSize-10) drawF(fX[i]-worldSize, fY[i]);
        if (fY[i] < 10) drawF(fX[i], fY[i]+worldSize); if (fY[i] > worldSize-10) drawF(fX[i], fY[i]-worldSize);
    }
    ctx.fill();

    const lowDetail = camera.zoom < 0.4;
    for (let i=0; i<MAX_POP; i++) {
        if (!oActive[i]) continue;
        let dx = Math.abs(oX[i] - camCX); let dy = Math.abs(oY[i] - camCY);
        if (dx > worldSize/2) dx = worldSize - dx; if (dy > worldSize/2) dy = worldSize - dy;
        const buffer = gSize[i] + (debugMode ? gSense[i] : 0) + 50;
        if (dx > viewW/2 + buffer || dy > viewH/2 + buffer) continue;

        const drawO = (x, y) => {
            if (lowDetail) {
                ctx.fillStyle = `hsl(${gHue[i]}, 70%, 50%)`;
                ctx.fillRect(x - gSize[i], y - gSize[i], gSize[i]*2, gSize[i]*2);
            } else {
                if (debugMode) {
                    ctx.beginPath(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.arc(x, y, gSense[i], 0, Math.PI*2); ctx.stroke();
                }
                if (gDefense[i] > 0.2) {
                    ctx.fillStyle = `hsl(${gHue[i]}, 70%, 50%)`;
                    ctx.beginPath();
                    const spikeLen = gDefense[i] * 6;
                    for(let j=0; j<5; j++) {
                        const ang = (j/5)*Math.PI*2;
                        ctx.lineTo(x + Math.cos(ang)*(gSize[i]+spikeLen), y + Math.sin(ang)*(gSize[i]+spikeLen));
                    }
                    ctx.fill();
                }
                ctx.beginPath(); ctx.fillStyle = `hsl(${gHue[i]}, 70%, 50%)`;
                ctx.arc(x, y, gSize[i], 0, Math.PI*2); ctx.fill();
                
                if (oEnergy[i] > gRepro[i] * 0.8) {
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(x, y, gSize[i]+3, 0, Math.PI*2); ctx.stroke();
                }
            }
        }
        drawO(oX[i], oY[i]);
        if (oX[i] < buffer) drawO(oX[i]+worldSize, oY[i]); if (oX[i] > worldSize-buffer) drawO(oX[i]-worldSize, oY[i]);
        if (oY[i] < buffer) drawO(oX[i], oY[i]+worldSize); if (oY[i] > worldSize-buffer) drawO(oX[i], oY[i]-worldSize);
    }
    ctx.restore();
}

function init() {
    activeCount = 0; foodCount = 0;
    oFreePtr = MAX_POP - 1; for(let i=0; i<MAX_POP; i++) { oFree[i] = MAX_POP - 1 - i; oActive[i] = 0; }
    fFreePtr = MAX_FOOD - 1; for(let i=0; i<MAX_FOOD; i++) { fFree[i] = MAX_FOOD - 1 - i; fActive[i] = 0; }
    
    ENV.zones = [];
    const targetZoneCount = Math.ceil(CONFIG.zoneDensity * (worldSize / 3000));
    for(let i=0; i<targetZoneCount; i++) {
        ENV.zones.push({
            pos: {x: Math.random() * worldSize, y: Math.random() * worldSize},
            radius: CONFIG.zoneSize,
            vel: {x: (Math.random()-0.5)*CONFIG.zoneDrift, y: (Math.random()-0.5)*CONFIG.zoneDrift}
        });
    }

    for(let i=0; i<CONFIG.initialPop; i++) spawnOrganism(Math.random()*worldSize, Math.random()*worldSize);
    spawnRandomFood(CONFIG.initialFood);
    
    if(canvas && ctx) {
        camera.x = worldSize/2 - (canvas.width / camera.zoom)/2;
        camera.y = worldSize/2 - (canvas.height / camera.zoom)/2;
        clampCamera();
    }
}

// --- 5. BOOTSTRAP ---
document.addEventListener('DOMContentLoaded', () => {
    canvas = document.getElementById('simCanvas');
    ctx = canvas.getContext('2d', { alpha: false });
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    
    miniCanvas = document.getElementById('minimap');
    miniCtx = miniCanvas.getContext('2d');

    histSpeedCtx = document.getElementById('hist-speed').getContext('2d');
    histSizeCtx = document.getElementById('hist-size').getContext('2d');
    histSenseCtx = document.getElementById('hist-sense').getContext('2d');
    histStorageCtx = document.getElementById('hist-storage').getContext('2d');
    histMetaCtx = document.getElementById('hist-meta').getContext('2d');
    histDefenseCtx = document.getElementById('hist-defense').getContext('2d');

    const els = {
        worldSize: safeGet('world-size-select'),
        simSpeed: safeGet('sim-speed'),
        mutRate: safeGet('mut-rate'),
        metabolism: safeGet('metabolism'),
        predation: safeGet('predation-toggle'),
        zones: safeGet('zones-toggle'),
        zoneDensity: safeGet('zone-density'),
        zoneSize: safeGet('zone-size'),
        zoneDrift: safeGet('zone-drift'),
        debug: safeGet('debug-toggle'),
        reset: safeGet('reset-btn'),
        mobBtn: safeGet('mobile-menu-btn'),
        mobMenu: safeGet('mobile-menu'),
        mobWorld: safeGet('mob-world-size'),
        mobPredation: safeGet('mob-predation'),
        mobZones: safeGet('mob-zones'),
        mobZoneDensity: safeGet('mob-zone-density'), 
        mobDebug: safeGet('mob-debug'),
        mobSpeed: safeGet('mob-speed'),
        mobMut: safeGet('mob-mut'),
        mobMetabolism: safeGet('mob-metabolism'),
        mobReset: safeGet('mob-reset')
    };

    // Binding Logic
    if(els.worldSize) els.worldSize.addEventListener('change', e => { worldSize = parseInt(e.target.value); if(els.mobWorld) els.mobWorld.value = worldSize; init(); });
    if(els.mobWorld) els.mobWorld.addEventListener('change', e => { worldSize = parseInt(e.target.value); if(els.worldSize) els.worldSize.value = worldSize; init(); });
    if(els.simSpeed) els.simSpeed.addEventListener('input', e => { simSpeed = parseInt(e.target.value); if(els.mobSpeed) els.mobSpeed.value = simSpeed; });
    if(els.mobSpeed) els.mobSpeed.addEventListener('input', e => { simSpeed = parseInt(e.target.value); if(els.simSpeed) els.simSpeed.value = simSpeed; });
    if(els.mutRate) els.mutRate.addEventListener('input', e => { CONFIG.mutationChance = parseInt(e.target.value)/100; if(els.mobMut) els.mobMut.value = e.target.value; });
    if(els.mobMut) els.mobMut.addEventListener('input', e => { CONFIG.mutationChance = parseInt(e.target.value)/100; if(els.mutRate) els.mutRate.value = e.target.value; });
    if(els.metabolism) els.metabolism.addEventListener('input', e => { CONFIG.baseMetabolism = (parseInt(e.target.value)/100)*0.01; if(els.mobMetabolism) els.mobMetabolism.value = e.target.value; });
    if(els.mobMetabolism) els.mobMetabolism.addEventListener('input', e => { CONFIG.baseMetabolism = (parseInt(e.target.value)/100)*0.01; if(els.metabolism) els.metabolism.value = e.target.value; });
    
    const togglePred = (v) => { predationActive = v; if(els.predation) els.predation.checked=v; if(els.mobPredation) els.mobPredation.checked=v; };
    if(els.predation) els.predation.addEventListener('change', e => togglePred(e.target.checked));
    if(els.mobPredation) els.mobPredation.addEventListener('change', e => togglePred(e.target.checked));
    
    const toggleZones = (v) => { ENV.activeZones = v; if(els.zones) els.zones.checked=v; if(els.mobZones) els.mobZones.checked=v; };
    if(els.zones) els.zones.addEventListener('change', e => toggleZones(e.target.checked));
    if(els.mobZones) els.mobZones.addEventListener('change', e => toggleZones(e.target.checked));

    const setZD = (v) => { CONFIG.zoneDensity = parseInt(v); if(els.zoneDensity) els.zoneDensity.value=v; if(els.mobZoneDensity) els.mobZoneDensity.value=v; };
    if(els.zoneDensity) els.zoneDensity.addEventListener('input', e => setZD(e.target.value));
    if(els.mobZoneDensity) els.mobZoneDensity.addEventListener('input', e => setZD(e.target.value));

    if(els.zoneSize) els.zoneSize.addEventListener('input', e => CONFIG.zoneSize = parseInt(e.target.value));
    if(els.zoneDrift) els.zoneDrift.addEventListener('input', e => CONFIG.zoneDrift = parseFloat(e.target.value)/10);

    const toggleDebug = (v) => { debugMode = v; if(els.debug) els.debug.checked=v; if(els.mobDebug) els.mobDebug.checked=v; };
    if(els.debug) els.debug.addEventListener('change', e => toggleDebug(e.target.checked));
    if(els.mobDebug) els.mobDebug.addEventListener('change', e => toggleDebug(e.target.checked));
    
    if(els.reset) els.reset.addEventListener('click', init);
    if(els.mobReset) els.mobReset.addEventListener('click', () => { init(); els.mobMenu.classList.add('hidden'); els.mobMenu.classList.remove('flex'); });
    if(els.mobBtn) els.mobBtn.addEventListener('click', () => { els.mobMenu.classList.toggle('hidden'); els.mobMenu.classList.toggle('flex'); });
    
    document.getElementById('stats-header').addEventListener('click', () => {
        document.getElementById('stats-card').classList.toggle('collapsed');
    });

    // Keyboard Input
    window.addEventListener('keydown', e => { keys[e.code] = true; });
    window.addEventListener('keyup', e => { keys[e.code] = false; });

    // Interaction
    canvas.addEventListener('mousedown', e => { isDragging = true; dragDistance = 0; lastMouse = { x: e.clientX, y: e.clientY }; });
    canvas.addEventListener('mousemove', e => { if (isDragging) { const dx = e.clientX - lastMouse.x; const dy = e.clientY - lastMouse.y; dragDistance += Math.abs(dx) + Math.abs(dy); camera.x -= dx / camera.zoom; camera.y -= dy / camera.zoom; clampCamera(); lastMouse = { x: e.clientX, y: e.clientY }; }});
    canvas.addEventListener('mouseup', e => isDragging = false); canvas.addEventListener('mouseleave', e => isDragging = false);
    canvas.addEventListener('click', e => { if (dragDistance < 5) spawnAt(e.clientX, e.clientY); });
    canvas.addEventListener('wheel', e => { e.preventDefault(); camera.zoom = Math.max(0.1, Math.min(3, camera.zoom - e.deltaY * 0.001 * camera.zoom)); clampCamera(); }, { passive: false });
    let initialPinchDist = 0, initialZoom = 1;
    canvas.addEventListener('touchstart', e => { if (e.touches.length === 1) { isDragging = true; dragDistance = 0; lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY }; } else if (e.touches.length === 2) { isDragging = false; const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; initialPinchDist = Math.hypot(dx, dy); initialZoom = camera.zoom; } }, { passive: false });
    canvas.addEventListener('touchmove', e => { e.preventDefault(); if (e.touches.length === 1 && isDragging) { const dx = e.touches[0].clientX - lastMouse.x; const dy = e.touches[0].clientY - lastMouse.y; dragDistance += Math.abs(dx) + Math.abs(dy); camera.x -= dx / camera.zoom; camera.y -= dy / camera.zoom; clampCamera(); lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY }; } else if (e.touches.length === 2) { const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; const dist = Math.hypot(dx, dy); if (initialPinchDist > 0) { camera.zoom = Math.max(0.1, Math.min(3, initialZoom * (dist / initialPinchDist))); clampCamera(); }}}, { passive: false });
    canvas.addEventListener('touchend', e => { isDragging = false; if (e.changedTouches.length > 0 && dragDistance < 10 && e.touches.length === 0) spawnAt(e.changedTouches[0].clientX, e.changedTouches[0].clientY); });
    
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth; canvas.height = window.innerHeight; clampCamera();
    });

    // START
    init();
    animate(0);
});

function processInput() {
    const speed = 15 / camera.zoom;
    if (keys['ArrowUp'] || keys['KeyW']) camera.y -= speed;
    if (keys['ArrowDown'] || keys['KeyS']) camera.y += speed;
    if (keys['ArrowLeft'] || keys['KeyA']) camera.x -= speed;
    if (keys['ArrowRight'] || keys['KeyD']) camera.x += speed;
    
    if (keys['Equal'] || keys['NumpadAdd']) camera.zoom = Math.min(3, camera.zoom * 1.02);
    if (keys['Minus'] || keys['NumpadSubtract']) camera.zoom = Math.max(0.1, camera.zoom * 0.98);

    if (keys['ArrowUp'] || keys['KeyW'] || keys['ArrowDown'] || keys['KeyS'] || 
        keys['ArrowLeft'] || keys['KeyA'] || keys['ArrowRight'] || keys['KeyD'] ||
        keys['Equal'] || keys['NumpadAdd'] || keys['Minus'] || keys['NumpadSubtract']) {
        clampCamera();
    }
}

function animate(time) {
    requestAnimationFrame(animate);
    const delta = time - lastTime; lastTime = time;
    
    processInput();
    updateEnvironment();

    for (let s = 0; s < simSpeed; s++) {
        updateGrid(); 
        if (Math.random() < 0.3) { let p = getBiasedSpawnPos(); spawnFood(p.x, p.y); }
        physicsStep();
    }
    
    if (activeCount === 0 && frameCount % 60 === 0) { 
        for(let i=0; i<10; i++) spawnOrganism(Math.random() * worldSize, Math.random() * worldSize);
        spawnRandomFood(50); 
    }

    draw();
    
    frameCount++;
    if (frameCount % 20 === 0) {
        const fpsEl = document.getElementById('fps-counter');
        if(fpsEl) fpsEl.innerText = Math.round(1000/delta) || 60;
        
        if(miniCtx) {
            miniCtx.fillStyle = '#000'; miniCtx.fillRect(0, 0, miniCtx.canvas.width, miniCtx.canvas.height);
            const scale = miniCtx.canvas.width / worldSize; 
            for (let i=0; i<MAX_POP; i++) {
                if(oActive[i]) {
                    miniCtx.fillStyle = `hsl(${gHue[i]}, 70%, 50%)`;
                    miniCtx.fillRect(oX[i] * scale, oY[i] * scale, 2, 2); 
                }
            }
            miniCtx.strokeStyle = '#555'; miniCtx.lineWidth = 1; 
            let camX = camera.x % worldSize; if (camX < 0) camX += worldSize; let camY = camera.y % worldSize; if (camY < 0) camY += worldSize;
            miniCtx.strokeRect(camX * scale, camY * scale, (canvas.width/camera.zoom) * scale, (canvas.height/camera.zoom) * scale);
        }

        const popEl = document.getElementById('pop-count');
        if(popEl) popEl.innerText = activeCount;
        const foodEl = document.getElementById('food-count');
        if(foodEl) foodEl.innerText = foodCount;
        const zoneEl = document.getElementById('zone-count');
        if(zoneEl) zoneEl.innerText = ENV.activeZones ? ENV.zones.length : "Off";
        updateHistograms();
    }
}
</script>
</body>
</html>